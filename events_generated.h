// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_MYMESSAGES_H_
#define FLATBUFFERS_GENERATED_EVENTS_MYMESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace MyMessages {

struct EventHolder;
struct EventHolderBuilder;

struct Event1;
struct Event1Builder;

struct Event2;
struct Event2Builder;

struct Event3;
struct Event3Builder;

struct EventN;
struct EventNBuilder;

enum EventTypes {
  EventTypes_NONE = 0,
  EventTypes_Event1 = 1,
  EventTypes_Event2 = 2,
  EventTypes_Event3 = 3,
  EventTypes_EventN = 4,
  EventTypes_MIN = EventTypes_NONE,
  EventTypes_MAX = EventTypes_EventN
};

inline const EventTypes (&EnumValuesEventTypes())[5] {
  static const EventTypes values[] = {
    EventTypes_NONE,
    EventTypes_Event1,
    EventTypes_Event2,
    EventTypes_Event3,
    EventTypes_EventN
  };
  return values;
}

inline const char * const *EnumNamesEventTypes() {
  static const char * const names[6] = {
    "NONE",
    "Event1",
    "Event2",
    "Event3",
    "EventN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventTypes(EventTypes e) {
  if (flatbuffers::IsOutRange(e, EventTypes_NONE, EventTypes_EventN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEventTypes()[index];
}

template<typename T> struct EventTypesTraits {
  static const EventTypes enum_value = EventTypes_NONE;
};

template<> struct EventTypesTraits<MyMessages::Event1> {
  static const EventTypes enum_value = EventTypes_Event1;
};

template<> struct EventTypesTraits<MyMessages::Event2> {
  static const EventTypes enum_value = EventTypes_Event2;
};

template<> struct EventTypesTraits<MyMessages::Event3> {
  static const EventTypes enum_value = EventTypes_Event3;
};

template<> struct EventTypesTraits<MyMessages::EventN> {
  static const EventTypes enum_value = EventTypes_EventN;
};

bool VerifyEventTypes(flatbuffers::Verifier &verifier, const void *obj, EventTypes type);
bool VerifyEventTypesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct EventHolder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventHolderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  MyMessages::EventTypes event_type() const {
    return static_cast<MyMessages::EventTypes>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const MyMessages::Event1 *event_as_Event1() const {
    return event_type() == MyMessages::EventTypes_Event1 ? static_cast<const MyMessages::Event1 *>(event()) : nullptr;
  }
  const MyMessages::Event2 *event_as_Event2() const {
    return event_type() == MyMessages::EventTypes_Event2 ? static_cast<const MyMessages::Event2 *>(event()) : nullptr;
  }
  const MyMessages::Event3 *event_as_Event3() const {
    return event_type() == MyMessages::EventTypes_Event3 ? static_cast<const MyMessages::Event3 *>(event()) : nullptr;
  }
  const MyMessages::EventN *event_as_EventN() const {
    return event_type() == MyMessages::EventTypes_EventN ? static_cast<const MyMessages::EventN *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEventTypes(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MyMessages::Event1 *EventHolder::event_as<MyMessages::Event1>() const {
  return event_as_Event1();
}

template<> inline const MyMessages::Event2 *EventHolder::event_as<MyMessages::Event2>() const {
  return event_as_Event2();
}

template<> inline const MyMessages::Event3 *EventHolder::event_as<MyMessages::Event3>() const {
  return event_as_Event3();
}

template<> inline const MyMessages::EventN *EventHolder::event_as<MyMessages::EventN>() const {
  return event_as_EventN();
}

struct EventHolderBuilder {
  typedef EventHolder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(MyMessages::EventTypes event_type) {
    fbb_.AddElement<uint8_t>(EventHolder::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(EventHolder::VT_EVENT, event);
  }
  explicit EventHolderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EventHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventHolder>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventHolder> CreateEventHolder(
    flatbuffers::FlatBufferBuilder &_fbb,
    MyMessages::EventTypes event_type = MyMessages::EventTypes_NONE,
    flatbuffers::Offset<void> event = 0) {
  EventHolderBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

struct Event1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Event1Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct Event1Builder {
  typedef Event1 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(Event1::VT_DATA, data, 0);
  }
  explicit Event1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Event1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event1> CreateEvent1(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t data = 0) {
  Event1Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Event2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Event2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct Event2Builder {
  typedef Event2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(Event2::VT_DATA, data, 0);
  }
  explicit Event2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Event2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event2> CreateEvent2(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t data = 0) {
  Event2Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Event3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Event3Builder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Event3Builder {
  typedef Event3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Event3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Event3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event3> CreateEvent3(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Event3Builder builder_(_fbb);
  return builder_.Finish();
}

struct EventN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct EventNBuilder {
  typedef EventN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(EventN::VT_DATA, data, 0);
  }
  explicit EventNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EventN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventN>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventN> CreateEventN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t data = 0) {
  EventNBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline bool VerifyEventTypes(flatbuffers::Verifier &verifier, const void *obj, EventTypes type) {
  switch (type) {
    case EventTypes_NONE: {
      return true;
    }
    case EventTypes_Event1: {
      auto ptr = reinterpret_cast<const MyMessages::Event1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventTypes_Event2: {
      auto ptr = reinterpret_cast<const MyMessages::Event2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventTypes_Event3: {
      auto ptr = reinterpret_cast<const MyMessages::Event3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventTypes_EventN: {
      auto ptr = reinterpret_cast<const MyMessages::EventN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventTypesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEventTypes(
        verifier,  values->Get(i), types->GetEnum<EventTypes>(i))) {
      return false;
    }
  }
  return true;
}

inline const MyMessages::EventHolder *GetEventHolder(const void *buf) {
  return flatbuffers::GetRoot<MyMessages::EventHolder>(buf);
}

inline const MyMessages::EventHolder *GetSizePrefixedEventHolder(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MyMessages::EventHolder>(buf);
}

inline bool VerifyEventHolderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MyMessages::EventHolder>(nullptr);
}

inline bool VerifySizePrefixedEventHolderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MyMessages::EventHolder>(nullptr);
}

inline void FinishEventHolderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MyMessages::EventHolder> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventHolderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MyMessages::EventHolder> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MyMessages

#endif  // FLATBUFFERS_GENERATED_EVENTS_MYMESSAGES_H_
